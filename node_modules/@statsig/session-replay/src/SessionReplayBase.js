"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionReplayBase = exports.forceStartRecording = exports.startRecording = exports.stopRecording = void 0;
const client_core_1 = require("@statsig/client-core");
const SessionReplayClient_1 = require("./SessionReplayClient");
const SessionReplayUtils_1 = require("./SessionReplayUtils");
function stopRecording(sdkKey) {
    var _a;
    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.stopRecording();
}
exports.stopRecording = stopRecording;
function startRecording(sdkKey) {
    var _a;
    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.startRecording();
}
exports.startRecording = startRecording;
function forceStartRecording(sdkKey) {
    var _a;
    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.forceStartRecording();
}
exports.forceStartRecording = forceStartRecording;
function _getInstanceFromSdkKey(sdkKey) {
    var _a, _b;
    const inst = sdkKey == null
        ? (0, client_core_1._getStatsigGlobal)().firstSRInstance
        : (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];
    return inst instanceof SessionReplayBase ? inst : null;
}
class SessionReplayBase {
    constructor(client, options) {
        this._sessionData = {
            startTime: -1,
            endTime: 0,
            clickCount: 0,
        };
        this._events = [];
        this._wasStopped = false;
        this._currentEventIndex = 0;
        this._totalLogs = 0;
        this._client = client;
        this._options = options;
        const { sdkKey, errorBoundary } = this._client.getContext();
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._replayer = new SessionReplayClient_1.SessionReplayClient();
        this._client.$on('pre_shutdown', () => this._shutdown());
        this._client.on('session_expired', () => {
            this._shutdown('session_expired');
        });
        if (!(0, client_core_1._isServerEnv)()) {
            const statsigGlobal = (0, client_core_1._getStatsigGlobal)();
            statsigGlobal.srInstances = Object.assign(Object.assign({}, statsigGlobal.srInstances), { [sdkKey]: this });
            if (!statsigGlobal.firstSRInstance) {
                statsigGlobal.firstSRInstance = this;
            }
        }
        this._currentSessionID = this._getSessionIdFromClient();
        this._subscribeToVisibilityChanged();
    }
    forceStartRecording() {
        this._wasStopped = false;
        this._attemptToStartRecording(true);
    }
    stopRecording() {
        this._wasStopped = true;
        this._shutdown();
    }
    startRecording() {
        var _a;
        this._wasStopped = false;
        this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);
    }
    isRecording() {
        return this._replayer.isRecording();
    }
    _logRecording(endReason) {
        if (this._events.length === 0) {
            return;
        }
        endReason = (0, client_core_1._isUnloading)() ? 'is_leaving_page' : endReason;
        this._logRecordingWithSessionID(this._currentSessionID, endReason);
    }
    _onVisibilityChanged(visibility) {
        if (visibility !== 'background') {
            return;
        }
        this._logRecording();
        this._client.flush().catch((e) => {
            this._errorBoundary.logError('SR::visibility', e);
        });
    }
    _subscribeToVisibilityChanged() {
        // Note: this exists as a separate function to ensure closure scope only contains `sdkKey`
        const { sdkKey } = this._client.getContext();
        (0, client_core_1._subscribeToVisiblityChanged)((vis) => {
            var _a, _b;
            const inst = (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];
            if (inst instanceof SessionReplayBase) {
                inst._onVisibilityChanged(vis);
            }
        });
    }
    _logRecordingWithSessionID(sessionID, endReason) {
        const data = this._sessionData;
        if (this._events.length === 0) {
            return;
        }
        const payload = JSON.stringify(this._events);
        const parts = (0, SessionReplayUtils_1._slicePayload)(payload);
        const slicedID = parts.length > 1 ? (0, client_core_1.getUUID)() : null;
        for (let i = 0; i < parts.length; i++) {
            const slice = parts[i];
            const event = (0, SessionReplayUtils_1._makeLoggableRrwebEvent)(slice, payload, sessionID, data, this._client.getContext().sdkInstanceID);
            if (slicedID != null) {
                (0, SessionReplayUtils_1._appendSlicedMetadata)(event.metadata, slicedID, i, parts.length, slice.length);
            }
            if (endReason) {
                event.metadata[endReason] = 'true';
            }
            this._totalLogs++;
            this._client.logEvent(event);
            if (slicedID != null) {
                this._client.flush().catch((e) => {
                    client_core_1.Log.error(e);
                });
            }
        }
        this._events = [];
        if (this._totalLogs > SessionReplayUtils_1.MAX_LOGS) {
            this._shutdown();
        }
    }
    _bumpSessionIdleTimerAndLogRecording() {
        this._getSessionIdFromClient();
        this._logRecording();
    }
    _getSessionIdFromClient() {
        return this._client.getContext().session.data.sessionID;
    }
    _shutdownImpl(endReason) {
        if (this._replayer.isRecording()) {
            this._replayer.stop();
            const handler = () => {
                client_core_1.StatsigMetadataProvider.add({ isRecordingSession: 'false' });
                this._client.off('logs_flushed', handler);
            };
            this._client.$on('logs_flushed', handler);
        }
        if (this._events.length === 0) {
            // only reset if session expired otherwise we might start recording again
            if (endReason === 'session_expired') {
                this._currentEventIndex = 0;
                this._sessionData = this._makeEmptySessionData();
            }
            return;
        }
        this._logRecording(endReason);
        // only reset if session expired otherwise we might start recording again
        if (endReason === 'session_expired') {
            this._currentEventIndex = 0;
            this._sessionData = this._makeEmptySessionData();
        }
    }
    _makeEmptySessionData() {
        return {
            startTime: -1,
            endTime: 0,
            clickCount: 0,
        };
    }
    _onRecordingEvent(event, data) {
        // The session has expired so we should stop recording
        if (this._currentSessionID !== this._getSessionIdFromClient()) {
            this._shutdown('session_expired');
            return;
        }
        if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {
            this._shutdown();
            return;
        }
        event.eventIndex = this._currentEventIndex++;
        // Update the session data
        this._sessionData.clickCount += data.clickCount;
        this._sessionData.startTime =
            this._sessionData.startTime === -1
                ? data.startTime
                : Math.min(this._sessionData.startTime, data.startTime);
        this._sessionData.endTime = Math.max(this._sessionData.endTime, data.endTime);
        const eventApproxSize = (0, client_core_1._fastApproxSizeOf)(event, SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES);
        if (eventApproxSize > SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES) {
            client_core_1.Log.warn(`SessionReplay event is too large (~${eventApproxSize} bytes) and will not be logged`, event);
            return;
        }
        const approxArraySizeBefore = (0, client_core_1._fastApproxSizeOf)(this._events, SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES);
        this._events.push(event);
        if (approxArraySizeBefore + eventApproxSize <
            SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES) {
            return;
        }
        if ((0, client_core_1._isCurrentlyVisible)()) {
            this._bumpSessionIdleTimerAndLogRecording();
        }
        else {
            this._logRecording();
        }
    }
}
exports.SessionReplayBase = SessionReplayBase;
