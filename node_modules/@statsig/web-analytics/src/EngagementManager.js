"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngagementManager = void 0;
const client_core_1 = require("@statsig/client-core");
const PAGE_INACTIVE_TIMEOUT = 600000; // 10 minutes
class EngagementManager {
    constructor() {
        this._lastScrollY = 0;
        this._maxScrollY = 0;
        this._lastScrollPercentage = 0;
        this._maxScrollPercentage = 0;
        this._lastPageViewTime = Date.now();
        this._inactiveTimer = null;
        this._onInactivityCallback = null;
        this._meaningfulEngagementOccurred = false;
        this._initializeScrollTracking();
    }
    _initializeScrollTracking() {
        const win = (0, client_core_1._getWindowSafe)();
        if (!win)
            return;
        win.addEventListener('scroll', () => this._handleScroll());
        win.addEventListener('scrollend', () => this._handleScroll());
        win.addEventListener('resize', () => this._handleScroll());
    }
    _handleScroll() {
        const win = (0, client_core_1._getWindowSafe)();
        const doc = (0, client_core_1._getDocumentSafe)();
        if (!win || !doc)
            return;
        const scrollHeight = doc.body.scrollHeight;
        const scrollY = win.scrollY || doc.documentElement.scrollTop || 0;
        const innerHeight = win.innerHeight;
        this._lastScrollY = scrollY;
        this._maxScrollY = Math.max(this._maxScrollY, scrollY);
        const currentScrollPercentage = Math.min(100, Math.round(((scrollY + innerHeight) / scrollHeight) * 100));
        this._lastScrollPercentage = currentScrollPercentage;
        this._maxScrollPercentage = Math.max(this._maxScrollPercentage, currentScrollPercentage);
        this.bumpInactiveTimer();
    }
    getScrollMetrics() {
        return {
            lastScrollY: this._lastScrollY,
            maxScrollY: this._maxScrollY,
            lastScrollPercentage: this._lastScrollPercentage,
            maxScrollPercentage: this._maxScrollPercentage,
            scrollDepth: this._maxScrollPercentage, // deprecated
        };
    }
    getPageViewLength() {
        return Date.now() - this._lastPageViewTime;
    }
    setLastPageViewTime(time) {
        this._lastPageViewTime = time;
    }
    startInactivityTracking(callback) {
        this._onInactivityCallback = callback;
    }
    bumpInactiveTimer() {
        const win = (0, client_core_1._getWindowSafe)();
        if (!win) {
            return;
        }
        if (this._inactiveTimer) {
            clearTimeout(this._inactiveTimer);
        }
        this._inactiveTimer = win.setTimeout(() => {
            if (this._onInactivityCallback) {
                this._onInactivityCallback();
            }
        }, PAGE_INACTIVE_TIMEOUT);
    }
    setMeaningfulEngagementOccurred(occurred) {
        this._meaningfulEngagementOccurred = occurred;
    }
    getPageViewEndMetadata() {
        const pageviewEndMetadata = Object.assign(Object.assign({}, this.getScrollMetrics()), { pageViewLength: this.getPageViewLength(), meaningfulEngagementOccurred: this._meaningfulEngagementOccurred });
        this.setMeaningfulEngagementOccurred(false);
        return pageviewEndMetadata;
    }
}
exports.EngagementManager = EngagementManager;
