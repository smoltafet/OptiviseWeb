{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventLogger = void 0;\nconst CacheKey_1 = require(\"./CacheKey\");\nconst Hashing_1 = require(\"./Hashing\");\nconst Log_1 = require(\"./Log\");\nconst NetworkConfig_1 = require(\"./NetworkConfig\");\nconst SafeJs_1 = require(\"./SafeJs\");\nconst StatsigEvent_1 = require(\"./StatsigEvent\");\nconst StatsigOptionsCommon_1 = require(\"./StatsigOptionsCommon\");\nconst StorageProvider_1 = require(\"./StorageProvider\");\nconst UrlConfiguration_1 = require(\"./UrlConfiguration\");\nconst VisibilityObserving_1 = require(\"./VisibilityObserving\");\nconst DEFAULT_QUEUE_SIZE = 100;\nconst DEFAULT_FLUSH_INTERVAL_MS = 10000;\nconst MAX_DEDUPER_KEYS = 1000;\nconst DEDUPER_WINDOW_DURATION_MS = 600000;\nconst MAX_FAILED_LOGS = 500;\nconst QUICK_FLUSH_WINDOW_MS = 200;\nconst EVENT_LOGGER_MAP = {};\nconst RetryFailedLogsTrigger = {\n  Startup: 'startup',\n  GainedFocus: 'gained_focus'\n};\nclass EventLogger {\n  static _safeFlushAndForget(sdkKey) {\n    var _a;\n    (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {\n      // noop\n    });\n  }\n  static _safeRetryFailedLogs(sdkKey) {\n    var _a;\n    (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);\n  }\n  constructor(_sdkKey, _emitter, _network, _options) {\n    var _a, _b;\n    this._sdkKey = _sdkKey;\n    this._emitter = _emitter;\n    this._network = _network;\n    this._options = _options;\n    this._queue = [];\n    this._lastExposureTimeMap = {};\n    this._nonExposedChecks = {};\n    this._hasRunQuickFlush = false;\n    this._creationTime = Date.now();\n    this._loggingEnabled = (_a = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a !== void 0 ? _a : (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly;\n    if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== undefined) {\n      Log_1.Log.warn('Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.');\n    }\n    this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;\n    const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;\n    this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);\n  }\n  setLogEventCompressionMode(mode) {\n    this._network.setLogEventCompressionMode(mode);\n  }\n  setLoggingEnabled(loggingEnabled) {\n    if (this._loggingEnabled === 'disabled' && loggingEnabled !== 'disabled') {\n      // load any pre consented events into memory\n      const storageKey = this._getStorageKey();\n      const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n      if (events) {\n        this._queue.push(...events);\n      }\n      StorageProvider_1.Storage.removeItem(storageKey);\n    }\n    this._loggingEnabled = loggingEnabled;\n  }\n  enqueue(event) {\n    if (!this._shouldLogEvent(event)) {\n      return;\n    }\n    this._normalizeAndAppendEvent(event);\n    this._quickFlushIfNeeded();\n    if (this._queue.length > this._maxQueueSize) {\n      EventLogger._safeFlushAndForget(this._sdkKey);\n    }\n  }\n  incrementNonExposureCount(name) {\n    var _a;\n    const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;\n    this._nonExposedChecks[name] = current + 1;\n  }\n  reset() {\n    // attempt to flush any remaining events\n    this.flush().catch(() => {\n      // noop\n    });\n    this._lastExposureTimeMap = {};\n  }\n  start() {\n    var _a;\n    const isServerEnv = (0, SafeJs_1._isServerEnv)();\n    if (isServerEnv && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== 'always') {\n      return;\n    }\n    EVENT_LOGGER_MAP[this._sdkKey] = this;\n    if (!isServerEnv) {\n      (0, VisibilityObserving_1._subscribeToVisiblityChanged)(visibility => {\n        if (visibility === 'background') {\n          EventLogger._safeFlushAndForget(this._sdkKey);\n        } else if (visibility === 'foreground') {\n          EventLogger._safeRetryFailedLogs(this._sdkKey);\n        }\n      });\n    }\n    this._retryFailedLogs(RetryFailedLogsTrigger.Startup);\n    this._startBackgroundFlushInterval();\n  }\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._flushIntervalId) {\n        clearInterval(this._flushIntervalId);\n        this._flushIntervalId = null;\n      }\n      delete EVENT_LOGGER_MAP[this._sdkKey];\n      yield this.flush();\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._appendAndResetNonExposedChecks();\n      if (this._queue.length === 0) {\n        return;\n      }\n      const events = this._queue;\n      this._queue = [];\n      yield this._sendEvents(events);\n    });\n  }\n  /**\n   * We 'Quick Flush' following the very first event enqueued\n   * within the quick flush window\n   */\n  _quickFlushIfNeeded() {\n    if (this._hasRunQuickFlush) {\n      return;\n    }\n    this._hasRunQuickFlush = true;\n    if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {\n      return;\n    }\n    setTimeout(() => EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);\n  }\n  _shouldLogEvent(event) {\n    var _a;\n    if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== 'always' && (0, SafeJs_1._isServerEnv)()) {\n      return false;\n    }\n    if (!(0, StatsigEvent_1._isExposureEvent)(event)) {\n      return true;\n    }\n    const user = event.user ? event.user : {\n      statsigEnvironment: undefined\n    };\n    const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);\n    const metadata = event.metadata ? event.metadata : {};\n    const key = [event.eventName, userKey, metadata['gate'], metadata['config'], metadata['ruleID'], metadata['allocatedExperiment'], metadata['parameterName'], String(metadata['isExplicitParameter']), metadata['reason']].join('|');\n    const previous = this._lastExposureTimeMap[key];\n    const now = Date.now();\n    if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {\n      return false;\n    }\n    if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {\n      this._lastExposureTimeMap = {};\n    }\n    this._lastExposureTimeMap[key] = now;\n    return true;\n  }\n  _sendEvents(events) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (this._loggingEnabled === 'disabled') {\n        this._saveFailedLogsToStorage(events);\n        return false;\n      }\n      try {\n        const isClosing = (0, VisibilityObserving_1._isUnloading)();\n        const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;\n        this._emitter({\n          name: 'pre_logs_flushed',\n          events\n        });\n        const response = shouldUseBeacon ? this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);\n        if (response.success) {\n          this._emitter({\n            name: 'logs_flushed',\n            events\n          });\n          return true;\n        } else {\n          Log_1.Log.warn('Failed to flush events.');\n          this._saveFailedLogsToStorage(events);\n          return false;\n        }\n      } catch (_c) {\n        Log_1.Log.warn('Failed to flush events.');\n        return false;\n      }\n    });\n  }\n  _sendEventsViaPost(events) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const result = yield this._network.post(this._getRequestData(events));\n      const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;\n      return {\n        success: code >= 200 && code < 300\n      };\n    });\n  }\n  _sendEventsViaBeacon(events) {\n    return {\n      success: this._network.beacon(this._getRequestData(events))\n    };\n  }\n  _getRequestData(events) {\n    return {\n      sdkKey: this._sdkKey,\n      data: {\n        events\n      },\n      urlConfig: this._logEventUrlConfig,\n      retries: 3,\n      isCompressable: true,\n      params: {\n        [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)\n      },\n      credentials: 'same-origin'\n    };\n  }\n  _saveFailedLogsToStorage(events) {\n    while (events.length > MAX_FAILED_LOGS) {\n      events.shift();\n    }\n    const storageKey = this._getStorageKey();\n    try {\n      const savedEvents = this._getFailedLogsFromStorage(storageKey);\n      (0, StorageProvider_1._setObjectInStorage)(storageKey, [...savedEvents, ...events]);\n    } catch (_a) {\n      Log_1.Log.warn('Unable to save failed logs to storage');\n    }\n  }\n  _getFailedLogsFromStorage(storageKey) {\n    let savedEvents = [];\n    try {\n      const retrieved = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n      if (Array.isArray(retrieved)) {\n        savedEvents = retrieved;\n      }\n      return savedEvents;\n    } catch (_a) {\n      return [];\n    }\n  }\n  _retryFailedLogs(trigger) {\n    const storageKey = this._getStorageKey();\n    (() => __awaiter(this, void 0, void 0, function* () {\n      if (!StorageProvider_1.Storage.isReady()) {\n        yield StorageProvider_1.Storage.isReadyResolver();\n      }\n      const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n      if (!events) {\n        return;\n      }\n      if (trigger === RetryFailedLogsTrigger.Startup) {\n        StorageProvider_1.Storage.removeItem(storageKey);\n      }\n      const isSuccess = yield this._sendEvents(events);\n      if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {\n        StorageProvider_1.Storage.removeItem(storageKey);\n      }\n    }))().catch(() => {\n      Log_1.Log.warn('Failed to flush stored logs');\n    });\n  }\n  _getStorageKey() {\n    return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;\n  }\n  _normalizeAndAppendEvent(event) {\n    if (event.user) {\n      event.user = Object.assign({}, event.user);\n      delete event.user.privateAttributes;\n    }\n    const extras = {};\n    const currentPage = this._getCurrentPageUrl();\n    if (currentPage) {\n      extras.statsigMetadata = {\n        currentPage\n      };\n    }\n    const final = Object.assign(Object.assign({}, event), extras);\n    Log_1.Log.debug('Enqueued Event:', final);\n    this._queue.push(final);\n  }\n  _appendAndResetNonExposedChecks() {\n    if (Object.keys(this._nonExposedChecks).length === 0) {\n      return;\n    }\n    this._normalizeAndAppendEvent({\n      eventName: 'statsig::non_exposed_checks',\n      user: null,\n      time: Date.now(),\n      metadata: {\n        checks: Object.assign({}, this._nonExposedChecks)\n      }\n    });\n    this._nonExposedChecks = {};\n  }\n  _getCurrentPageUrl() {\n    var _a;\n    if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {\n      return;\n    }\n    return (0, SafeJs_1._getCurrentPageUrlSafe)();\n  }\n  _startBackgroundFlushInterval() {\n    var _a, _b;\n    const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;\n    const intervalId = setInterval(() => {\n      const logger = EVENT_LOGGER_MAP[this._sdkKey];\n      if (!logger || logger._flushIntervalId !== intervalId) {\n        clearInterval(intervalId);\n      } else {\n        EventLogger._safeFlushAndForget(this._sdkKey);\n      }\n    }, flushInterval);\n    this._flushIntervalId = intervalId;\n  }\n}\nexports.EventLogger = EventLogger;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","EventLogger","CacheKey_1","require","Hashing_1","Log_1","NetworkConfig_1","SafeJs_1","StatsigEvent_1","StatsigOptionsCommon_1","StorageProvider_1","UrlConfiguration_1","VisibilityObserving_1","DEFAULT_QUEUE_SIZE","DEFAULT_FLUSH_INTERVAL_MS","MAX_DEDUPER_KEYS","DEDUPER_WINDOW_DURATION_MS","MAX_FAILED_LOGS","QUICK_FLUSH_WINDOW_MS","EVENT_LOGGER_MAP","RetryFailedLogsTrigger","Startup","GainedFocus","_safeFlushAndForget","sdkKey","_a","flush","catch","_safeRetryFailedLogs","_retryFailedLogs","constructor","_sdkKey","_emitter","_network","_options","_b","_queue","_lastExposureTimeMap","_nonExposedChecks","_hasRunQuickFlush","_creationTime","Date","now","_loggingEnabled","loggingEnabled","disableLogging","LoggingEnabledOption","disabled","browserOnly","undefined","Log","warn","_maxQueueSize","loggingBufferMaxSize","config","networkConfig","_logEventUrlConfig","UrlConfiguration","Endpoint","_rgstr","logEventUrl","api","logEventFallbackUrls","setLogEventCompressionMode","mode","setLoggingEnabled","storageKey","_getStorageKey","events","_getObjectFromStorage","push","Storage","removeItem","enqueue","event","_shouldLogEvent","_normalizeAndAppendEvent","_quickFlushIfNeeded","length","incrementNonExposureCount","name","current","reset","start","isServerEnv","_isServerEnv","_subscribeToVisiblityChanged","visibility","_startBackgroundFlushInterval","stop","_flushIntervalId","clearInterval","_appendAndResetNonExposedChecks","_sendEvents","setTimeout","_isExposureEvent","user","statsigEnvironment","userKey","_getUserStorageKey","metadata","key","eventName","String","join","previous","keys","_saveFailedLogsToStorage","isClosing","_isUnloading","shouldUseBeacon","isBeaconSupported","networkOverrideFunc","response","_sendEventsViaBeacon","_sendEventsViaPost","success","_c","post","_getRequestData","code","beacon","data","urlConfig","retries","isCompressable","params","NetworkParam","EventCount","credentials","shift","savedEvents","_getFailedLogsFromStorage","_setObjectInStorage","retrieved","Array","isArray","trigger","isReady","isReadyResolver","isSuccess","_DJB2","assign","privateAttributes","extras","currentPage","_getCurrentPageUrl","statsigMetadata","final","debug","time","checks","includeCurrentPageUrlWithEvents","_getCurrentPageUrlSafe","flushInterval","loggingIntervalMs","intervalId","setInterval","logger"],"sources":["/Users/sidiq/Documents/OptiviseWeb/node_modules/@statsig/client-core/src/EventLogger.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventLogger = void 0;\nconst CacheKey_1 = require(\"./CacheKey\");\nconst Hashing_1 = require(\"./Hashing\");\nconst Log_1 = require(\"./Log\");\nconst NetworkConfig_1 = require(\"./NetworkConfig\");\nconst SafeJs_1 = require(\"./SafeJs\");\nconst StatsigEvent_1 = require(\"./StatsigEvent\");\nconst StatsigOptionsCommon_1 = require(\"./StatsigOptionsCommon\");\nconst StorageProvider_1 = require(\"./StorageProvider\");\nconst UrlConfiguration_1 = require(\"./UrlConfiguration\");\nconst VisibilityObserving_1 = require(\"./VisibilityObserving\");\nconst DEFAULT_QUEUE_SIZE = 100;\nconst DEFAULT_FLUSH_INTERVAL_MS = 10000;\nconst MAX_DEDUPER_KEYS = 1000;\nconst DEDUPER_WINDOW_DURATION_MS = 600000;\nconst MAX_FAILED_LOGS = 500;\nconst QUICK_FLUSH_WINDOW_MS = 200;\nconst EVENT_LOGGER_MAP = {};\nconst RetryFailedLogsTrigger = {\n    Startup: 'startup',\n    GainedFocus: 'gained_focus',\n};\nclass EventLogger {\n    static _safeFlushAndForget(sdkKey) {\n        var _a;\n        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {\n            // noop\n        });\n    }\n    static _safeRetryFailedLogs(sdkKey) {\n        var _a;\n        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);\n    }\n    constructor(_sdkKey, _emitter, _network, _options) {\n        var _a, _b;\n        this._sdkKey = _sdkKey;\n        this._emitter = _emitter;\n        this._network = _network;\n        this._options = _options;\n        this._queue = [];\n        this._lastExposureTimeMap = {};\n        this._nonExposedChecks = {};\n        this._hasRunQuickFlush = false;\n        this._creationTime = Date.now();\n        this._loggingEnabled =\n            (_a = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a !== void 0 ? _a : ((_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true\n                ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled\n                : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly);\n        if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== undefined) {\n            Log_1.Log.warn('Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.');\n        }\n        this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;\n        const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;\n        this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);\n    }\n    setLogEventCompressionMode(mode) {\n        this._network.setLogEventCompressionMode(mode);\n    }\n    setLoggingEnabled(loggingEnabled) {\n        if (this._loggingEnabled === 'disabled' && loggingEnabled !== 'disabled') {\n            // load any pre consented events into memory\n            const storageKey = this._getStorageKey();\n            const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n            if (events) {\n                this._queue.push(...events);\n            }\n            StorageProvider_1.Storage.removeItem(storageKey);\n        }\n        this._loggingEnabled = loggingEnabled;\n    }\n    enqueue(event) {\n        if (!this._shouldLogEvent(event)) {\n            return;\n        }\n        this._normalizeAndAppendEvent(event);\n        this._quickFlushIfNeeded();\n        if (this._queue.length > this._maxQueueSize) {\n            EventLogger._safeFlushAndForget(this._sdkKey);\n        }\n    }\n    incrementNonExposureCount(name) {\n        var _a;\n        const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;\n        this._nonExposedChecks[name] = current + 1;\n    }\n    reset() {\n        // attempt to flush any remaining events\n        this.flush().catch(() => {\n            // noop\n        });\n        this._lastExposureTimeMap = {};\n    }\n    start() {\n        var _a;\n        const isServerEnv = (0, SafeJs_1._isServerEnv)();\n        if (isServerEnv && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== 'always') {\n            return;\n        }\n        EVENT_LOGGER_MAP[this._sdkKey] = this;\n        if (!isServerEnv) {\n            (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {\n                if (visibility === 'background') {\n                    EventLogger._safeFlushAndForget(this._sdkKey);\n                }\n                else if (visibility === 'foreground') {\n                    EventLogger._safeRetryFailedLogs(this._sdkKey);\n                }\n            });\n        }\n        this._retryFailedLogs(RetryFailedLogsTrigger.Startup);\n        this._startBackgroundFlushInterval();\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._flushIntervalId) {\n                clearInterval(this._flushIntervalId);\n                this._flushIntervalId = null;\n            }\n            delete EVENT_LOGGER_MAP[this._sdkKey];\n            yield this.flush();\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._appendAndResetNonExposedChecks();\n            if (this._queue.length === 0) {\n                return;\n            }\n            const events = this._queue;\n            this._queue = [];\n            yield this._sendEvents(events);\n        });\n    }\n    /**\n     * We 'Quick Flush' following the very first event enqueued\n     * within the quick flush window\n     */\n    _quickFlushIfNeeded() {\n        if (this._hasRunQuickFlush) {\n            return;\n        }\n        this._hasRunQuickFlush = true;\n        if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {\n            return;\n        }\n        setTimeout(() => EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);\n    }\n    _shouldLogEvent(event) {\n        var _a;\n        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== 'always' && (0, SafeJs_1._isServerEnv)()) {\n            return false;\n        }\n        if (!(0, StatsigEvent_1._isExposureEvent)(event)) {\n            return true;\n        }\n        const user = event.user ? event.user : { statsigEnvironment: undefined };\n        const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);\n        const metadata = event.metadata ? event.metadata : {};\n        const key = [\n            event.eventName,\n            userKey,\n            metadata['gate'],\n            metadata['config'],\n            metadata['ruleID'],\n            metadata['allocatedExperiment'],\n            metadata['parameterName'],\n            String(metadata['isExplicitParameter']),\n            metadata['reason'],\n        ].join('|');\n        const previous = this._lastExposureTimeMap[key];\n        const now = Date.now();\n        if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {\n            return false;\n        }\n        if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {\n            this._lastExposureTimeMap = {};\n        }\n        this._lastExposureTimeMap[key] = now;\n        return true;\n    }\n    _sendEvents(events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (this._loggingEnabled === 'disabled') {\n                this._saveFailedLogsToStorage(events);\n                return false;\n            }\n            try {\n                const isClosing = (0, VisibilityObserving_1._isUnloading)();\n                const shouldUseBeacon = isClosing &&\n                    this._network.isBeaconSupported() &&\n                    ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;\n                this._emitter({\n                    name: 'pre_logs_flushed',\n                    events,\n                });\n                const response = shouldUseBeacon\n                    ? this._sendEventsViaBeacon(events)\n                    : yield this._sendEventsViaPost(events);\n                if (response.success) {\n                    this._emitter({\n                        name: 'logs_flushed',\n                        events,\n                    });\n                    return true;\n                }\n                else {\n                    Log_1.Log.warn('Failed to flush events.');\n                    this._saveFailedLogsToStorage(events);\n                    return false;\n                }\n            }\n            catch (_c) {\n                Log_1.Log.warn('Failed to flush events.');\n                return false;\n            }\n        });\n    }\n    _sendEventsViaPost(events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const result = yield this._network.post(this._getRequestData(events));\n            const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;\n            return { success: code >= 200 && code < 300 };\n        });\n    }\n    _sendEventsViaBeacon(events) {\n        return {\n            success: this._network.beacon(this._getRequestData(events)),\n        };\n    }\n    _getRequestData(events) {\n        return {\n            sdkKey: this._sdkKey,\n            data: {\n                events,\n            },\n            urlConfig: this._logEventUrlConfig,\n            retries: 3,\n            isCompressable: true,\n            params: {\n                [NetworkConfig_1.NetworkParam.EventCount]: String(events.length),\n            },\n            credentials: 'same-origin',\n        };\n    }\n    _saveFailedLogsToStorage(events) {\n        while (events.length > MAX_FAILED_LOGS) {\n            events.shift();\n        }\n        const storageKey = this._getStorageKey();\n        try {\n            const savedEvents = this._getFailedLogsFromStorage(storageKey);\n            (0, StorageProvider_1._setObjectInStorage)(storageKey, [...savedEvents, ...events]);\n        }\n        catch (_a) {\n            Log_1.Log.warn('Unable to save failed logs to storage');\n        }\n    }\n    _getFailedLogsFromStorage(storageKey) {\n        let savedEvents = [];\n        try {\n            const retrieved = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n            if (Array.isArray(retrieved)) {\n                savedEvents = retrieved;\n            }\n            return savedEvents;\n        }\n        catch (_a) {\n            return [];\n        }\n    }\n    _retryFailedLogs(trigger) {\n        const storageKey = this._getStorageKey();\n        (() => __awaiter(this, void 0, void 0, function* () {\n            if (!StorageProvider_1.Storage.isReady()) {\n                yield StorageProvider_1.Storage.isReadyResolver();\n            }\n            const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);\n            if (!events) {\n                return;\n            }\n            if (trigger === RetryFailedLogsTrigger.Startup) {\n                StorageProvider_1.Storage.removeItem(storageKey);\n            }\n            const isSuccess = yield this._sendEvents(events);\n            if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {\n                StorageProvider_1.Storage.removeItem(storageKey);\n            }\n        }))().catch(() => {\n            Log_1.Log.warn('Failed to flush stored logs');\n        });\n    }\n    _getStorageKey() {\n        return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;\n    }\n    _normalizeAndAppendEvent(event) {\n        if (event.user) {\n            event.user = Object.assign({}, event.user);\n            delete event.user.privateAttributes;\n        }\n        const extras = {};\n        const currentPage = this._getCurrentPageUrl();\n        if (currentPage) {\n            extras.statsigMetadata = { currentPage };\n        }\n        const final = Object.assign(Object.assign({}, event), extras);\n        Log_1.Log.debug('Enqueued Event:', final);\n        this._queue.push(final);\n    }\n    _appendAndResetNonExposedChecks() {\n        if (Object.keys(this._nonExposedChecks).length === 0) {\n            return;\n        }\n        this._normalizeAndAppendEvent({\n            eventName: 'statsig::non_exposed_checks',\n            user: null,\n            time: Date.now(),\n            metadata: {\n                checks: Object.assign({}, this._nonExposedChecks),\n            },\n        });\n        this._nonExposedChecks = {};\n    }\n    _getCurrentPageUrl() {\n        var _a;\n        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {\n            return;\n        }\n        return (0, SafeJs_1._getCurrentPageUrlSafe)();\n    }\n    _startBackgroundFlushInterval() {\n        var _a, _b;\n        const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;\n        const intervalId = setInterval(() => {\n            const logger = EVENT_LOGGER_MAP[this._sdkKey];\n            if (!logger || logger._flushIntervalId !== intervalId) {\n                clearInterval(intervalId);\n            }\n            else {\n                EventLogger._safeFlushAndForget(this._sdkKey);\n            }\n        }, flushInterval);\n        this._flushIntervalId = intervalId;\n    }\n}\nexports.EventLogger = EventLogger;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}