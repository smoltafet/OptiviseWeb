{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst client_core_1 = require(\"@statsig/client-core\");\nconst EvaluationStore_1 = require(\"./EvaluationStore\");\nconst Network_1 = require(\"./Network\");\nconst ParamStoreGetterFactory_1 = require(\"./ParamStoreGetterFactory\");\nconst StatsigEvaluationsDataAdapter_1 = require(\"./StatsigEvaluationsDataAdapter\");\nclass StatsigClient extends client_core_1.StatsigClientBase {\n  /**\n   * Retrieves an instance of the StatsigClient based on the provided SDK key.\n   *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.\n   *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.\n   *  If no instance exists for the given SDK key, a new StatsigClient instance will be created and returned.\n   *\n   * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.\n   * @returns {StatsigClient} Returns the StatsigClient instance associated with the given SDK key, creating a new one if needed.\n   */\n  static instance(sdkKey) {\n    const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);\n    if (instance instanceof StatsigClient) {\n      return instance;\n    }\n    client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? 'StatsigClient.instance is not supported in server environments' : 'Unable to find StatsigClient instance');\n    return new StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : '', {});\n  }\n  /**\n   * StatsigClient constructor\n   *\n   * @param {string} sdkKey A Statsig client SDK key. eg \"client-xyz123...\"\n   * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.\n   * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.\n   */\n  constructor(sdkKey, user, options = null) {\n    var _a, _b;\n    client_core_1.SDKType._setClientType(sdkKey, 'javascript-client');\n    const network = new Network_1.default(options, e => {\n      this.$emt(e);\n    });\n    super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);\n    this._possibleFirstTouchMetadata = {};\n    /**\n     * Retrieves the value of a feature gate for the current user, represented as a {@link FeatureGate} object.\n     *\n     * @param {string} name - The name of the feature gate to retrieve.\n     * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {FeatureGate} - The {@link FeatureGate} object representing the gate's current evaluation results for the user.\n     */\n    this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));\n    /**\n     * Retrieves the value of a dynamic config for the current user.\n     *\n     * @param {string} name The name of the dynamic config to get.\n     * @param {DynamicConfigEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {DynamicConfig} - The {@link DynamicConfig} object representing the dynamic configs's current evaluation results for the user.\n     */\n    this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));\n    /**\n     * Retrieves the value of a experiment for the current user.\n     *\n     * @param {string} name The name of the experiment to get.\n     * @param {ExperimentEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {Experiment} - The {@link Experiment} object representing the experiments's current evaluation results for the user.\n     */\n    this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));\n    /**\n     * Retrieves the list of all Dynamic Configs and Experiments for the current user.\n     *\n     * @returns {string[]} The list of all Dynamic Config and Experiment names for the current user. Note - these will be hashed unless you've disabled hashing.\n     * This is intended to be used for debugging.\n     */\n    this.getConfigList = this._memoize(client_core_1.MemoPrefix._configList, this._getConfigListImpl.bind(this));\n    /**\n     * Retrieves the value of a layer for the current user.\n     *\n     * @param {string} name The name of the layer to get.\n     * @param {LayerEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {Layer} - The {@link Layer} object representing the layers's current evaluation results for the user.\n     */\n    this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));\n    /**\n     * Retrieves the value of a parameter store for the current user.\n     *\n     * @param {string} name The name of the parameter store to get.\n     * @param {ParameterStoreEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {ParameterStore} - The {@link ParameterStore} object representing the parameter store's current mappings for the user.\n     */\n    this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));\n    this._store = new EvaluationStore_1.default(sdkKey);\n    this._network = network;\n    this._user = this._configureUser(user, options);\n    this._sdkInstanceID = (0, client_core_1.getUUID)();\n    const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];\n    for (const plugin of plugins) {\n      plugin.bind(this);\n    }\n  }\n  /**\n   * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.\n   * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.\n   * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.\n   *\n   * @see {@link initializeAsync} for the asynchronous version of this method.\n   */\n  initializeSync(options) {\n    var _a;\n    if (this.loadingStatus !== 'Uninitialized') {\n      return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ['MultipleInitializations', ...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])]);\n    }\n    this._logger.start();\n    return this.updateUserSync(this._user, options);\n  }\n  /**\n   * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.\n   * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,\n   * there might be a transition from cached to network values during the session, which can affect consistency.\n   * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.\n   *\n   * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.\n   * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.\n   * @see {@link initializeSync} for the synchronous version of this method.\n   */\n  initializeAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._initializePromise) {\n        return this._initializePromise;\n      }\n      this._initializePromise = this._initializeAsyncImpl(options);\n      return this._initializePromise;\n    });\n  }\n  /**\n   * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.\n   * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.\n   * This method ensures the client is quickly ready with available data.\n   *\n   * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.\n   * @see {@link updateUserAsync} for the asynchronous version of this method.\n   */\n  updateUserSync(user, options) {\n    const startTime = performance.now();\n    try {\n      return this._updateUserSyncImpl(user, options, startTime);\n    } catch (e) {\n      const err = e instanceof Error ? e : new Error(String(e));\n      return this._createErrorUpdateDetails(err, startTime);\n    }\n  }\n  _updateUserSyncImpl(user, options, startTime) {\n    var _a;\n    const warnings = [...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])];\n    this._resetForUser(user);\n    const result = this.dataAdapter.getDataSync(this._user);\n    if (result == null) {\n      warnings.push('NoCachedValues');\n    }\n    this._store.setValues(result, this._user);\n    this._finalizeUpdate(result);\n    const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;\n    if (disable === true || disable == null && (result === null || result === void 0 ? void 0 : result.source) === 'Bootstrap') {\n      return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);\n    }\n    this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);\n    return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);\n  }\n  /**\n   * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.\n   * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,\n   * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.\n   * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.\n   *\n   * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.\n   * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.\n   * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.\n   * @see {@link updateUserSync} for the synchronous version of this method.\n   */\n  updateUserAsync(user, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const startTime = performance.now();\n      try {\n        return yield this._updateUserAsyncImpl(user, options);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        return this._createErrorUpdateDetails(err, startTime);\n      }\n    });\n  }\n  _updateUserAsyncImpl(user, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._resetForUser(user);\n      const initiator = this._user;\n      client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);\n      let result = this.dataAdapter.getDataSync(initiator);\n      this._store.setValues(result, this._user);\n      this._setStatus('Loading', result);\n      result = yield this.dataAdapter.getDataAsync(result, initiator, options);\n      // ensure the user hasn't changed while we were waiting\n      if (initiator !== this._user) {\n        return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error('User changed during update'), this._network.getLastUsedInitUrlAndReset());\n      }\n      let isUsingNetworkValues = false;\n      if (result != null) {\n        client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);\n        isUsingNetworkValues = this._store.setValues(result, this._user);\n        client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {\n          success: isUsingNetworkValues\n        });\n      }\n      this._finalizeUpdate(result);\n      if (!isUsingNetworkValues) {\n        this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);\n        this.$emt({\n          name: 'initialization_failure'\n        });\n      }\n      client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());\n      const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);\n      return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());\n    });\n  }\n  /**\n   * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.\n   *\n   * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.\n   */\n  getContext() {\n    return {\n      sdkKey: this._sdkKey,\n      options: this._options,\n      values: this._store.getValues(),\n      user: JSON.parse(JSON.stringify(this._user)),\n      errorBoundary: this._errorBoundary,\n      session: client_core_1.StatsigSession.get(this._sdkKey),\n      stableID: client_core_1.StableID.get(this._sdkKey),\n      sdkInstanceID: this._sdkInstanceID\n    };\n  }\n  /**\n   * Retrieves the value of a feature gate for the current user, represented as a simple boolean.\n   *\n   * @param {string} name - The name of the feature gate to retrieve.\n   * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n   * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.\n   */\n  checkGate(name, options) {\n    return this.getFeatureGate(name, options).value;\n  }\n  /**\n   * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.\n   *\n   * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.\n   * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.\n   * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.\n   */\n  logEvent(eventOrName, value, metadata) {\n    const event = typeof eventOrName === 'string' ? {\n      eventName: eventOrName,\n      value,\n      metadata\n    } : eventOrName;\n    this.$emt({\n      name: 'log_event_called',\n      event\n    });\n    this._logger.enqueue(Object.assign(Object.assign({}, event), {\n      user: this._user,\n      time: Date.now()\n    }));\n  }\n  /**\n   * Updates the user with analytics only metadata. This will override any existing analytics only metadata.\n   *\n   * @param {Record<string, string | number | boolean>} metadata - The metadata to add to the user.\n   */\n  updateUserWithAnalyticsOnlyMetadata(metadata) {\n    this._user = this._configureUser(Object.assign(Object.assign({}, this._user), {\n      analyticsOnlyMetadata: metadata\n    }), this._options);\n  }\n  _primeReadyRipcord() {\n    this.$on('error', () => {\n      this.loadingStatus === 'Loading' && this._finalizeUpdate(null);\n    });\n  }\n  _initializeAsyncImpl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!client_core_1.Storage.isReady()) {\n        yield client_core_1.Storage.isReadyResolver();\n      }\n      this._logger.start();\n      return this.updateUserAsync(this._user, options);\n    });\n  }\n  _createErrorUpdateDetails(error, startTime) {\n    var _a;\n    return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])]);\n  }\n  _finalizeUpdate(values) {\n    this._store.finalize();\n    this._setStatus('Ready', values);\n  }\n  _runPostUpdate(current, user) {\n    this.dataAdapter.getDataAsync(current, user, {\n      priority: 'low'\n    }).catch(err => {\n      client_core_1.Log.error('An error occurred after update.', err);\n    });\n  }\n  _resetForUser(user) {\n    this._logger.reset();\n    this._store.reset();\n    this._user = this._configureUser(user, this._options);\n  }\n  _configureUser(originalUser, options) {\n    var _a, _b, _c;\n    const user = (0, client_core_1._normalizeUser)(originalUser, options);\n    const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;\n    if (stableIdOverride) {\n      const readyPromise = (_c = (_b = this.storageProvider).isReadyResolver) === null || _c === void 0 ? void 0 : _c.call(_b);\n      if (readyPromise) {\n        readyPromise.then(() => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey), () => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey));\n      } else {\n        client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);\n      }\n    }\n    // Only attach first touch metadata if it's not empty\n    if (Object.keys(this._possibleFirstTouchMetadata).length > 0) {\n      user.analyticsOnlyMetadata = Object.assign(Object.assign({}, user.analyticsOnlyMetadata), this._possibleFirstTouchMetadata);\n    }\n    return user;\n  }\n  _getFeatureGateImpl(name, options) {\n    var _a, _b;\n    const {\n      result: evaluation,\n      details\n    } = this._store.getGate(name);\n    const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);\n    const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);\n    const result = overridden !== null && overridden !== void 0 ? overridden : gate;\n    this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);\n    this.$emt({\n      name: 'gate_evaluation',\n      gate: result\n    });\n    return result;\n  }\n  _getDynamicConfigImpl(name, options) {\n    var _a, _b;\n    const {\n      result: evaluation,\n      details\n    } = this._store.getConfig(name);\n    const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);\n    const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);\n    const result = overridden !== null && overridden !== void 0 ? overridden : config;\n    this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);\n    this.$emt({\n      name: 'dynamic_config_evaluation',\n      dynamicConfig: result\n    });\n    return result;\n  }\n  _getExperimentImpl(name, options) {\n    var _a, _b, _c, _d;\n    const {\n      result: evaluation,\n      details\n    } = this._store.getConfig(name);\n    const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);\n    if (experiment.__evaluation != null) {\n      experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());\n    }\n    const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);\n    const result = overridden !== null && overridden !== void 0 ? overridden : experiment;\n    this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);\n    this.$emt({\n      name: 'experiment_evaluation',\n      experiment: result\n    });\n    return result;\n  }\n  _getConfigListImpl() {\n    return this._store.getConfigList();\n  }\n  _getLayerImpl(name, options) {\n    var _a, _b, _c;\n    const {\n      result: evaluation,\n      details\n    } = this._store.getLayer(name);\n    const layer = (0, client_core_1._makeLayer)(name, details, evaluation);\n    const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);\n    if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {\n      this._logger.incrementNonExposureCount(name);\n    }\n    const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, param => {\n      if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {\n        return;\n      }\n      this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);\n    });\n    this.$emt({\n      name: 'layer_evaluation',\n      layer: result\n    });\n    return result;\n  }\n  _getParameterStoreImpl(name, options) {\n    var _a, _b;\n    const {\n      result: configuration,\n      details\n    } = this._store.getParamStore(name);\n    this._logger.incrementNonExposureCount(name);\n    const paramStore = {\n      name,\n      details: details,\n      __configuration: configuration,\n      get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options)\n    };\n    const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);\n    if (overridden != null) {\n      paramStore.__configuration = overridden.config;\n      paramStore.details = overridden.details;\n      paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);\n    }\n    return paramStore;\n  }\n}\nexports.default = StatsigClient;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","client_core_1","require","EvaluationStore_1","Network_1","ParamStoreGetterFactory_1","StatsigEvaluationsDataAdapter_1","StatsigClient","StatsigClientBase","instance","sdkKey","_getStatsigGlobal","Log","warn","_isServerEnv","constructor","user","options","_a","_b","SDKType","_setClientType","network","default","$emt","dataAdapter","StatsigEvaluationsDataAdapter","_possibleFirstTouchMetadata","getFeatureGate","_memoize","MemoPrefix","_gate","_getFeatureGateImpl","bind","getDynamicConfig","_dynamicConfig","_getDynamicConfigImpl","getExperiment","_experiment","_getExperimentImpl","getConfigList","_configList","_getConfigListImpl","getLayer","_layer","_getLayerImpl","getParameterStore","_paramStore","_getParameterStoreImpl","_store","_network","_user","_configureUser","_sdkInstanceID","getUUID","plugins","plugin","initializeSync","loadingStatus","createUpdateDetails","getSource","getWarnings","_logger","start","updateUserSync","initializeAsync","_initializePromise","_initializeAsyncImpl","startTime","performance","now","_updateUserSyncImpl","err","Error","String","_createErrorUpdateDetails","warnings","_resetForUser","getDataSync","push","setValues","_finalizeUpdate","disable","disableBackgroundCacheRefresh","source","_errorBoundary","getLastSeenErrorAndReset","getLastUsedInitUrlAndReset","_runPostUpdate","updateUserAsync","_updateUserAsyncImpl","initiator","Diagnostics","_markInitOverallStart","_sdkKey","_setStatus","getDataAsync","isUsingNetworkValues","_markInitProcessStart","_markInitProcessEnd","success","attachErrorIfNoneExists","UPDATE_DETAIL_ERROR_MESSAGES","NO_NETWORK_DATA","name","_markInitOverallEnd","getCurrentSourceDetails","initDuration","_enqueueDiagnosticsEvent","_options","getContext","values","getValues","JSON","parse","stringify","errorBoundary","session","StatsigSession","get","stableID","StableID","sdkInstanceID","checkGate","logEvent","eventOrName","metadata","event","eventName","enqueue","assign","time","Date","updateUserWithAnalyticsOnlyMetadata","analyticsOnlyMetadata","_primeReadyRipcord","$on","Storage","isReady","isReadyResolver","error","finalize","current","priority","catch","reset","originalUser","_c","_normalizeUser","stableIdOverride","customIDs","readyPromise","storageProvider","call","setOverride","keys","length","evaluation","details","getGate","gate","_makeFeatureGate","overridden","overrideAdapter","getGateOverride","_enqueueExposure","_createGateExposure","getExposureMapping","getConfig","config","_makeDynamicConfig","getDynamicConfigOverride","_createConfigExposure","dynamicConfig","_d","experiment","_makeExperiment","__evaluation","secondary_exposures","_mapExposures","getExperimentOverride","layer","_makeLayer","getLayerOverride","disableExposureLog","incrementNonExposureCount","_mergeOverride","__value","param","_createLayerParameterExposure","configuration","getParamStore","paramStore","__configuration","_makeParamStoreGetter","getParamStoreOverride"],"sources":["/Users/sidiq/Documents/OptiviseWeb/node_modules/@statsig/js-client/src/StatsigClient.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_core_1 = require(\"@statsig/client-core\");\nconst EvaluationStore_1 = require(\"./EvaluationStore\");\nconst Network_1 = require(\"./Network\");\nconst ParamStoreGetterFactory_1 = require(\"./ParamStoreGetterFactory\");\nconst StatsigEvaluationsDataAdapter_1 = require(\"./StatsigEvaluationsDataAdapter\");\nclass StatsigClient extends client_core_1.StatsigClientBase {\n    /**\n     * Retrieves an instance of the StatsigClient based on the provided SDK key.\n     *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.\n     *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.\n     *  If no instance exists for the given SDK key, a new StatsigClient instance will be created and returned.\n     *\n     * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.\n     * @returns {StatsigClient} Returns the StatsigClient instance associated with the given SDK key, creating a new one if needed.\n     */\n    static instance(sdkKey) {\n        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);\n        if (instance instanceof StatsigClient) {\n            return instance;\n        }\n        client_core_1.Log.warn((0, client_core_1._isServerEnv)()\n            ? 'StatsigClient.instance is not supported in server environments'\n            : 'Unable to find StatsigClient instance');\n        return new StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : '', {});\n    }\n    /**\n     * StatsigClient constructor\n     *\n     * @param {string} sdkKey A Statsig client SDK key. eg \"client-xyz123...\"\n     * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.\n     * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.\n     */\n    constructor(sdkKey, user, options = null) {\n        var _a, _b;\n        client_core_1.SDKType._setClientType(sdkKey, 'javascript-client');\n        const network = new Network_1.default(options, (e) => {\n            this.$emt(e);\n        });\n        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);\n        this._possibleFirstTouchMetadata = {};\n        /**\n         * Retrieves the value of a feature gate for the current user, represented as a {@link FeatureGate} object.\n         *\n         * @param {string} name - The name of the feature gate to retrieve.\n         * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n         * @returns {FeatureGate} - The {@link FeatureGate} object representing the gate's current evaluation results for the user.\n         */\n        this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));\n        /**\n         * Retrieves the value of a dynamic config for the current user.\n         *\n         * @param {string} name The name of the dynamic config to get.\n         * @param {DynamicConfigEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n         * @returns {DynamicConfig} - The {@link DynamicConfig} object representing the dynamic configs's current evaluation results for the user.\n         */\n        this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));\n        /**\n         * Retrieves the value of a experiment for the current user.\n         *\n         * @param {string} name The name of the experiment to get.\n         * @param {ExperimentEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n         * @returns {Experiment} - The {@link Experiment} object representing the experiments's current evaluation results for the user.\n         */\n        this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));\n        /**\n         * Retrieves the list of all Dynamic Configs and Experiments for the current user.\n         *\n         * @returns {string[]} The list of all Dynamic Config and Experiment names for the current user. Note - these will be hashed unless you've disabled hashing.\n         * This is intended to be used for debugging.\n         */\n        this.getConfigList = this._memoize(client_core_1.MemoPrefix._configList, this._getConfigListImpl.bind(this));\n        /**\n         * Retrieves the value of a layer for the current user.\n         *\n         * @param {string} name The name of the layer to get.\n         * @param {LayerEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n         * @returns {Layer} - The {@link Layer} object representing the layers's current evaluation results for the user.\n         */\n        this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));\n        /**\n         * Retrieves the value of a parameter store for the current user.\n         *\n         * @param {string} name The name of the parameter store to get.\n         * @param {ParameterStoreEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n         * @returns {ParameterStore} - The {@link ParameterStore} object representing the parameter store's current mappings for the user.\n         */\n        this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));\n        this._store = new EvaluationStore_1.default(sdkKey);\n        this._network = network;\n        this._user = this._configureUser(user, options);\n        this._sdkInstanceID = (0, client_core_1.getUUID)();\n        const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];\n        for (const plugin of plugins) {\n            plugin.bind(this);\n        }\n    }\n    /**\n     * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.\n     * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.\n     * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.\n     *\n     * @see {@link initializeAsync} for the asynchronous version of this method.\n     */\n    initializeSync(options) {\n        var _a;\n        if (this.loadingStatus !== 'Uninitialized') {\n            return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ['MultipleInitializations', ...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])]);\n        }\n        this._logger.start();\n        return this.updateUserSync(this._user, options);\n    }\n    /**\n     * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.\n     * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,\n     * there might be a transition from cached to network values during the session, which can affect consistency.\n     * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.\n     *\n     * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.\n     * @see {@link initializeSync} for the synchronous version of this method.\n     */\n    initializeAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._initializePromise) {\n                return this._initializePromise;\n            }\n            this._initializePromise = this._initializeAsyncImpl(options);\n            return this._initializePromise;\n        });\n    }\n    /**\n     * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.\n     * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.\n     * This method ensures the client is quickly ready with available data.\n     *\n     * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.\n     * @see {@link updateUserAsync} for the asynchronous version of this method.\n     */\n    updateUserSync(user, options) {\n        const startTime = performance.now();\n        try {\n            return this._updateUserSyncImpl(user, options, startTime);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : new Error(String(e));\n            return this._createErrorUpdateDetails(err, startTime);\n        }\n    }\n    _updateUserSyncImpl(user, options, startTime) {\n        var _a;\n        const warnings = [...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])];\n        this._resetForUser(user);\n        const result = this.dataAdapter.getDataSync(this._user);\n        if (result == null) {\n            warnings.push('NoCachedValues');\n        }\n        this._store.setValues(result, this._user);\n        this._finalizeUpdate(result);\n        const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;\n        if (disable === true ||\n            (disable == null && (result === null || result === void 0 ? void 0 : result.source) === 'Bootstrap')) {\n            return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);\n        }\n        this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);\n        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);\n    }\n    /**\n     * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.\n     * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,\n     * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.\n     * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.\n     *\n     * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.\n     * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.\n     * @see {@link updateUserSync} for the synchronous version of this method.\n     */\n    updateUserAsync(user, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = performance.now();\n            try {\n                return yield this._updateUserAsyncImpl(user, options);\n            }\n            catch (e) {\n                const err = e instanceof Error ? e : new Error(String(e));\n                return this._createErrorUpdateDetails(err, startTime);\n            }\n        });\n    }\n    _updateUserAsyncImpl(user, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._resetForUser(user);\n            const initiator = this._user;\n            client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);\n            let result = this.dataAdapter.getDataSync(initiator);\n            this._store.setValues(result, this._user);\n            this._setStatus('Loading', result);\n            result = yield this.dataAdapter.getDataAsync(result, initiator, options);\n            // ensure the user hasn't changed while we were waiting\n            if (initiator !== this._user) {\n                return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error('User changed during update'), this._network.getLastUsedInitUrlAndReset());\n            }\n            let isUsingNetworkValues = false;\n            if (result != null) {\n                client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);\n                isUsingNetworkValues = this._store.setValues(result, this._user);\n                client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {\n                    success: isUsingNetworkValues,\n                });\n            }\n            this._finalizeUpdate(result);\n            if (!isUsingNetworkValues) {\n                this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);\n                this.$emt({ name: 'initialization_failure' });\n            }\n            client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());\n            const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);\n            return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());\n        });\n    }\n    /**\n     * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.\n     *\n     * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.\n     */\n    getContext() {\n        return {\n            sdkKey: this._sdkKey,\n            options: this._options,\n            values: this._store.getValues(),\n            user: JSON.parse(JSON.stringify(this._user)),\n            errorBoundary: this._errorBoundary,\n            session: client_core_1.StatsigSession.get(this._sdkKey),\n            stableID: client_core_1.StableID.get(this._sdkKey),\n            sdkInstanceID: this._sdkInstanceID,\n        };\n    }\n    /**\n     * Retrieves the value of a feature gate for the current user, represented as a simple boolean.\n     *\n     * @param {string} name - The name of the feature gate to retrieve.\n     * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.\n     * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.\n     */\n    checkGate(name, options) {\n        return this.getFeatureGate(name, options).value;\n    }\n    /**\n     * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.\n     *\n     * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.\n     * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.\n     * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.\n     */\n    logEvent(eventOrName, value, metadata) {\n        const event = typeof eventOrName === 'string'\n            ? {\n                eventName: eventOrName,\n                value,\n                metadata,\n            }\n            : eventOrName;\n        this.$emt({\n            name: 'log_event_called',\n            event,\n        });\n        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));\n    }\n    /**\n     * Updates the user with analytics only metadata. This will override any existing analytics only metadata.\n     *\n     * @param {Record<string, string | number | boolean>} metadata - The metadata to add to the user.\n     */\n    updateUserWithAnalyticsOnlyMetadata(metadata) {\n        this._user = this._configureUser(Object.assign(Object.assign({}, this._user), { analyticsOnlyMetadata: metadata }), this._options);\n    }\n    _primeReadyRipcord() {\n        this.$on('error', () => {\n            this.loadingStatus === 'Loading' && this._finalizeUpdate(null);\n        });\n    }\n    _initializeAsyncImpl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!client_core_1.Storage.isReady()) {\n                yield client_core_1.Storage.isReadyResolver();\n            }\n            this._logger.start();\n            return this.updateUserAsync(this._user, options);\n        });\n    }\n    _createErrorUpdateDetails(error, startTime) {\n        var _a;\n        return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...((_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : [])]);\n    }\n    _finalizeUpdate(values) {\n        this._store.finalize();\n        this._setStatus('Ready', values);\n    }\n    _runPostUpdate(current, user) {\n        this.dataAdapter\n            .getDataAsync(current, user, { priority: 'low' })\n            .catch((err) => {\n            client_core_1.Log.error('An error occurred after update.', err);\n        });\n    }\n    _resetForUser(user) {\n        this._logger.reset();\n        this._store.reset();\n        this._user = this._configureUser(user, this._options);\n    }\n    _configureUser(originalUser, options) {\n        var _a, _b, _c;\n        const user = (0, client_core_1._normalizeUser)(originalUser, options);\n        const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;\n        if (stableIdOverride) {\n            const readyPromise = (_c = (_b = this.storageProvider).isReadyResolver) === null || _c === void 0 ? void 0 : _c.call(_b);\n            if (readyPromise) {\n                readyPromise.then(() => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey), () => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey));\n            }\n            else {\n                client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);\n            }\n        }\n        // Only attach first touch metadata if it's not empty\n        if (Object.keys(this._possibleFirstTouchMetadata).length > 0) {\n            user.analyticsOnlyMetadata = Object.assign(Object.assign({}, user.analyticsOnlyMetadata), this._possibleFirstTouchMetadata);\n        }\n        return user;\n    }\n    _getFeatureGateImpl(name, options) {\n        var _a, _b;\n        const { result: evaluation, details } = this._store.getGate(name);\n        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);\n        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);\n        const result = overridden !== null && overridden !== void 0 ? overridden : gate;\n        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);\n        this.$emt({ name: 'gate_evaluation', gate: result });\n        return result;\n    }\n    _getDynamicConfigImpl(name, options) {\n        var _a, _b;\n        const { result: evaluation, details } = this._store.getConfig(name);\n        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);\n        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);\n        const result = overridden !== null && overridden !== void 0 ? overridden : config;\n        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);\n        this.$emt({ name: 'dynamic_config_evaluation', dynamicConfig: result });\n        return result;\n    }\n    _getExperimentImpl(name, options) {\n        var _a, _b, _c, _d;\n        const { result: evaluation, details } = this._store.getConfig(name);\n        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);\n        if (experiment.__evaluation != null) {\n            experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());\n        }\n        const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);\n        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;\n        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);\n        this.$emt({ name: 'experiment_evaluation', experiment: result });\n        return result;\n    }\n    _getConfigListImpl() {\n        return this._store.getConfigList();\n    }\n    _getLayerImpl(name, options) {\n        var _a, _b, _c;\n        const { result: evaluation, details } = this._store.getLayer(name);\n        const layer = (0, client_core_1._makeLayer)(name, details, evaluation);\n        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);\n        if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {\n            this._logger.incrementNonExposureCount(name);\n        }\n        const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, (param) => {\n            if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {\n                return;\n            }\n            this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);\n        });\n        this.$emt({ name: 'layer_evaluation', layer: result });\n        return result;\n    }\n    _getParameterStoreImpl(name, options) {\n        var _a, _b;\n        const { result: configuration, details } = this._store.getParamStore(name);\n        this._logger.incrementNonExposureCount(name);\n        const paramStore = {\n            name,\n            details: details,\n            __configuration: configuration,\n            get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options),\n        };\n        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);\n        if (overridden != null) {\n            paramStore.__configuration = overridden.config;\n            paramStore.details = overridden.details;\n            paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);\n        }\n        return paramStore;\n    }\n}\nexports.default = StatsigClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}