{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TriggeredSessionReplay = exports.runStatsigTriggeredSessionReplay = exports.StatsigTriggeredSessionReplayPlugin = void 0;\nconst client_core_1 = require(\"@statsig/client-core\");\nconst SessionReplayBase_1 = require(\"./SessionReplayBase\");\nconst SessionReplayUtils_1 = require(\"./SessionReplayUtils\");\nclass StatsigTriggeredSessionReplayPlugin {\n  constructor(options) {\n    this.options = options;\n    this.__plugin = 'triggered-session-replay';\n  }\n  bind(client) {\n    runStatsigTriggeredSessionReplay(client, this.options);\n  }\n}\nexports.StatsigTriggeredSessionReplayPlugin = StatsigTriggeredSessionReplayPlugin;\nfunction runStatsigTriggeredSessionReplay(client, options) {\n  new TriggeredSessionReplay(client, options);\n}\nexports.runStatsigTriggeredSessionReplay = runStatsigTriggeredSessionReplay;\nclass TriggeredSessionReplay extends SessionReplayBase_1.SessionReplayBase {\n  constructor(client, options) {\n    var _a;\n    super(client, options);\n    this._runningEventData = [];\n    this._isActiveRecording = false;\n    this._subscribeToClientEvents(options);\n    if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {\n      this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n    } else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {\n      this._attemptToStartRollingWindow();\n    }\n  }\n  _subscribeToClientEvents(options) {\n    this._subscribeToValuesUpdated(options);\n    this._subscribeToLogEventCalled();\n    this._subscribeToGateEvaluation();\n    this._subscribeToExperimentEvaluation();\n  }\n  _subscribeToValuesUpdated(options) {\n    this._client.$on('values_updated', () => {\n      var _a;\n      if (!this._wasStopped) {\n        if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {\n          this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n        } else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {\n          this._attemptToStartRollingWindow();\n        }\n      }\n    });\n  }\n  _subscribeToLogEventCalled() {\n    this._client.$on('log_event_called', event => {\n      var _a;\n      if (this._wasStopped) {\n        return;\n      }\n      const values = this._client.getContext().values;\n      const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;\n      if (passedTargeting === false || (values === null || values === void 0 ? void 0 : values.session_recording_event_triggers) == null) {\n        return;\n      }\n      const trigger = values.session_recording_event_triggers[event.event.eventName];\n      if (trigger == null) {\n        return;\n      }\n      if (trigger.passes_sampling === false) {\n        return;\n      }\n      const targetValues = trigger.values;\n      if (targetValues == null) {\n        this._attemptToStartRecording(true);\n        return;\n      }\n      if (targetValues.includes(String((_a = event.event.value) !== null && _a !== void 0 ? _a : ''))) {\n        this._attemptToStartRecording(true);\n        return;\n      }\n    });\n  }\n  _subscribeToGateEvaluation() {\n    this._client.$on('gate_evaluation', event => {\n      this._tryStartExposureRecording(event.gate.name, String(event.gate.value));\n    });\n  }\n  _subscribeToExperimentEvaluation() {\n    this._client.$on('experiment_evaluation', event => {\n      var _a;\n      this._tryStartExposureRecording(event.experiment.name, (_a = event.experiment.groupName) !== null && _a !== void 0 ? _a : '');\n    });\n  }\n  _tryStartExposureRecording(name, value) {\n    var _a;\n    if (this._wasStopped) {\n      return;\n    }\n    const values = this._client.getContext().values;\n    const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;\n    if (passedTargeting === false || (values === null || values === void 0 ? void 0 : values.session_recording_exposure_triggers) == null) {\n      return;\n    }\n    const trigger = (_a = values.session_recording_exposure_triggers[name]) !== null && _a !== void 0 ? _a : values.session_recording_exposure_triggers[(0, client_core_1._DJB2)(name)];\n    if (trigger == null) {\n      return;\n    }\n    if (trigger.passes_sampling === false) {\n      return;\n    }\n    const targetValues = trigger.values;\n    if (targetValues == null) {\n      this._attemptToStartRecording(true);\n      return;\n    }\n    if (targetValues.includes(value)) {\n      this._attemptToStartRecording(true);\n      return;\n    }\n  }\n  forceStartRecording() {\n    super.forceStartRecording();\n  }\n  stopRecording() {\n    this._isActiveRecording = false;\n    this._runningEventData = [];\n    super.stopRecording();\n  }\n  _handleStartActiveRecording() {\n    this._isActiveRecording = true;\n    if (this._runningEventData.length === 0) {\n      return;\n    }\n    const currentEvents = this._runningEventData.map(e => e.events).flat();\n    for (let i = 0; i < currentEvents.length; i++) {\n      currentEvents[i].event.eventIndex = i;\n      this._sessionData.clickCount += currentEvents[i].data.clickCount;\n      this._sessionData.startTime = this._sessionData.startTime === -1 ? currentEvents[i].data.startTime : Math.min(this._sessionData.startTime, currentEvents[i].data.startTime);\n      this._sessionData.endTime = Math.max(this._sessionData.endTime, currentEvents[i].data.endTime);\n    }\n    this._events = currentEvents.map(e => e.event);\n    this._currentEventIndex = currentEvents.length;\n    if ((0, client_core_1._isCurrentlyVisible)()) {\n      this._bumpSessionIdleTimerAndLogRecording();\n    } else {\n      this._logRecording();\n    }\n    // stop recording and since it will be started again\n    this._replayer.stop();\n  }\n  _shutdown(endReason) {\n    this._isActiveRecording = false;\n    this._runningEventData = [];\n    super._shutdownImpl(endReason);\n  }\n  _onRecordingEvent(event, data, isCheckOut) {\n    if (!this._isActiveRecording) {\n      // The session has expired so we should clear the current data\n      if (this._currentSessionID !== this._getSessionIdFromClient()) {\n        this._shutdown('session_expired');\n        return;\n      }\n      if (isCheckOut && event.type === 4 ||\n      // Type 4 and type 2 both show up as checkout events but we only want to start a new entry for type 4\n      this._runningEventData.length === 0) {\n        // We only want to keep two entries\n        if (this._runningEventData.length > 1) {\n          this._runningEventData.shift();\n        }\n        this._runningEventData.push({\n          events: [{\n            event,\n            data\n          }]\n        });\n      } else {\n        this._runningEventData[this._runningEventData.length - 1].events.push({\n          event,\n          data\n        });\n      }\n      return;\n    }\n    super._onRecordingEvent(event, data);\n  }\n  _attemptToStartRollingWindow() {\n    var _a, _b;\n    const values = this._client.getContext().values;\n    if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {\n      this._shutdown();\n      return;\n    }\n    if (this._replayer.isRecording()) {\n      return;\n    }\n    this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {\n      this._shutdown();\n    }, true);\n  }\n  _attemptToStartRecording(force = false) {\n    var _a, _b;\n    if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {\n      return;\n    }\n    const values = this._client.getContext().values;\n    if ((values === null || values === void 0 ? void 0 : values.recording_blocked) === true) {\n      this._shutdown();\n      return;\n    }\n    if (!force && (values === null || values === void 0 ? void 0 : values.can_record_session) !== true) {\n      this._shutdown();\n      return;\n    }\n    if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {\n      this._shutdown();\n      return;\n    }\n    this._handleStartActiveRecording();\n    this._wasStopped = false;\n    client_core_1.StatsigMetadataProvider.add({\n      isRecordingSession: 'true'\n    });\n    if (this._replayer.isRecording()) {\n      return;\n    }\n    this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {\n      this._shutdown();\n    });\n  }\n}\nexports.TriggeredSessionReplay = TriggeredSessionReplay;","map":{"version":3,"names":["Object","defineProperty","exports","value","TriggeredSessionReplay","runStatsigTriggeredSessionReplay","StatsigTriggeredSessionReplayPlugin","client_core_1","require","SessionReplayBase_1","SessionReplayUtils_1","constructor","options","__plugin","bind","client","SessionReplayBase","_a","_runningEventData","_isActiveRecording","_subscribeToClientEvents","autoStartRecording","_attemptToStartRecording","_options","forceRecording","keepRollingWindow","_attemptToStartRollingWindow","_subscribeToValuesUpdated","_subscribeToLogEventCalled","_subscribeToGateEvaluation","_subscribeToExperimentEvaluation","_client","$on","_wasStopped","event","values","getContext","passedTargeting","passes_session_recording_targeting","session_recording_event_triggers","trigger","eventName","passes_sampling","targetValues","includes","String","_tryStartExposureRecording","gate","name","experiment","groupName","session_recording_exposure_triggers","_DJB2","forceStartRecording","stopRecording","_handleStartActiveRecording","length","currentEvents","map","e","events","flat","i","eventIndex","_sessionData","clickCount","data","startTime","Math","min","endTime","max","_events","_currentEventIndex","_isCurrentlyVisible","_bumpSessionIdleTimerAndLogRecording","_logRecording","_replayer","stop","_shutdown","endReason","_shutdownImpl","_onRecordingEvent","isCheckOut","_currentSessionID","_getSessionIdFromClient","type","shift","push","_b","isRecording","record","d","rrwebConfig","force","_totalLogs","MAX_LOGS","recording_blocked","can_record_session","StatsigMetadataProvider","add","isRecordingSession"],"sources":["/Users/sidiq/Documents/OptiviseWeb/node_modules/@statsig/session-replay/src/TriggeredSessionReplay.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TriggeredSessionReplay = exports.runStatsigTriggeredSessionReplay = exports.StatsigTriggeredSessionReplayPlugin = void 0;\nconst client_core_1 = require(\"@statsig/client-core\");\nconst SessionReplayBase_1 = require(\"./SessionReplayBase\");\nconst SessionReplayUtils_1 = require(\"./SessionReplayUtils\");\nclass StatsigTriggeredSessionReplayPlugin {\n    constructor(options) {\n        this.options = options;\n        this.__plugin = 'triggered-session-replay';\n    }\n    bind(client) {\n        runStatsigTriggeredSessionReplay(client, this.options);\n    }\n}\nexports.StatsigTriggeredSessionReplayPlugin = StatsigTriggeredSessionReplayPlugin;\nfunction runStatsigTriggeredSessionReplay(client, options) {\n    new TriggeredSessionReplay(client, options);\n}\nexports.runStatsigTriggeredSessionReplay = runStatsigTriggeredSessionReplay;\nclass TriggeredSessionReplay extends SessionReplayBase_1.SessionReplayBase {\n    constructor(client, options) {\n        var _a;\n        super(client, options);\n        this._runningEventData = [];\n        this._isActiveRecording = false;\n        this._subscribeToClientEvents(options);\n        if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {\n            this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n        }\n        else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {\n            this._attemptToStartRollingWindow();\n        }\n    }\n    _subscribeToClientEvents(options) {\n        this._subscribeToValuesUpdated(options);\n        this._subscribeToLogEventCalled();\n        this._subscribeToGateEvaluation();\n        this._subscribeToExperimentEvaluation();\n    }\n    _subscribeToValuesUpdated(options) {\n        this._client.$on('values_updated', () => {\n            var _a;\n            if (!this._wasStopped) {\n                if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {\n                    this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n                }\n                else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {\n                    this._attemptToStartRollingWindow();\n                }\n            }\n        });\n    }\n    _subscribeToLogEventCalled() {\n        this._client.$on('log_event_called', (event) => {\n            var _a;\n            if (this._wasStopped) {\n                return;\n            }\n            const values = this._client.getContext().values;\n            const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;\n            if (passedTargeting === false ||\n                (values === null || values === void 0 ? void 0 : values.session_recording_event_triggers) == null) {\n                return;\n            }\n            const trigger = values.session_recording_event_triggers[event.event.eventName];\n            if (trigger == null) {\n                return;\n            }\n            if (trigger.passes_sampling === false) {\n                return;\n            }\n            const targetValues = trigger.values;\n            if (targetValues == null) {\n                this._attemptToStartRecording(true);\n                return;\n            }\n            if (targetValues.includes(String((_a = event.event.value) !== null && _a !== void 0 ? _a : ''))) {\n                this._attemptToStartRecording(true);\n                return;\n            }\n        });\n    }\n    _subscribeToGateEvaluation() {\n        this._client.$on('gate_evaluation', (event) => {\n            this._tryStartExposureRecording(event.gate.name, String(event.gate.value));\n        });\n    }\n    _subscribeToExperimentEvaluation() {\n        this._client.$on('experiment_evaluation', (event) => {\n            var _a;\n            this._tryStartExposureRecording(event.experiment.name, (_a = event.experiment.groupName) !== null && _a !== void 0 ? _a : '');\n        });\n    }\n    _tryStartExposureRecording(name, value) {\n        var _a;\n        if (this._wasStopped) {\n            return;\n        }\n        const values = this._client.getContext().values;\n        const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;\n        if (passedTargeting === false ||\n            (values === null || values === void 0 ? void 0 : values.session_recording_exposure_triggers) == null) {\n            return;\n        }\n        const trigger = (_a = values.session_recording_exposure_triggers[name]) !== null && _a !== void 0 ? _a : values.session_recording_exposure_triggers[(0, client_core_1._DJB2)(name)];\n        if (trigger == null) {\n            return;\n        }\n        if (trigger.passes_sampling === false) {\n            return;\n        }\n        const targetValues = trigger.values;\n        if (targetValues == null) {\n            this._attemptToStartRecording(true);\n            return;\n        }\n        if (targetValues.includes(value)) {\n            this._attemptToStartRecording(true);\n            return;\n        }\n    }\n    forceStartRecording() {\n        super.forceStartRecording();\n    }\n    stopRecording() {\n        this._isActiveRecording = false;\n        this._runningEventData = [];\n        super.stopRecording();\n    }\n    _handleStartActiveRecording() {\n        this._isActiveRecording = true;\n        if (this._runningEventData.length === 0) {\n            return;\n        }\n        const currentEvents = this._runningEventData.map((e) => e.events).flat();\n        for (let i = 0; i < currentEvents.length; i++) {\n            currentEvents[i].event.eventIndex = i;\n            this._sessionData.clickCount += currentEvents[i].data.clickCount;\n            this._sessionData.startTime =\n                this._sessionData.startTime === -1\n                    ? currentEvents[i].data.startTime\n                    : Math.min(this._sessionData.startTime, currentEvents[i].data.startTime);\n            this._sessionData.endTime = Math.max(this._sessionData.endTime, currentEvents[i].data.endTime);\n        }\n        this._events = currentEvents.map((e) => e.event);\n        this._currentEventIndex = currentEvents.length;\n        if ((0, client_core_1._isCurrentlyVisible)()) {\n            this._bumpSessionIdleTimerAndLogRecording();\n        }\n        else {\n            this._logRecording();\n        }\n        // stop recording and since it will be started again\n        this._replayer.stop();\n    }\n    _shutdown(endReason) {\n        this._isActiveRecording = false;\n        this._runningEventData = [];\n        super._shutdownImpl(endReason);\n    }\n    _onRecordingEvent(event, data, isCheckOut) {\n        if (!this._isActiveRecording) {\n            // The session has expired so we should clear the current data\n            if (this._currentSessionID !== this._getSessionIdFromClient()) {\n                this._shutdown('session_expired');\n                return;\n            }\n            if ((isCheckOut && event.type === 4) || // Type 4 and type 2 both show up as checkout events but we only want to start a new entry for type 4\n                this._runningEventData.length === 0) {\n                // We only want to keep two entries\n                if (this._runningEventData.length > 1) {\n                    this._runningEventData.shift();\n                }\n                this._runningEventData.push({ events: [{ event, data }] });\n            }\n            else {\n                this._runningEventData[this._runningEventData.length - 1].events.push({\n                    event,\n                    data,\n                });\n            }\n            return;\n        }\n        super._onRecordingEvent(event, data);\n    }\n    _attemptToStartRollingWindow() {\n        var _a, _b;\n        const values = this._client.getContext().values;\n        if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {\n            this._shutdown();\n            return;\n        }\n        if (this._replayer.isRecording()) {\n            return;\n        }\n        this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {\n            this._shutdown();\n        }, true);\n    }\n    _attemptToStartRecording(force = false) {\n        var _a, _b;\n        if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {\n            return;\n        }\n        const values = this._client.getContext().values;\n        if ((values === null || values === void 0 ? void 0 : values.recording_blocked) === true) {\n            this._shutdown();\n            return;\n        }\n        if (!force && (values === null || values === void 0 ? void 0 : values.can_record_session) !== true) {\n            this._shutdown();\n            return;\n        }\n        if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {\n            this._shutdown();\n            return;\n        }\n        this._handleStartActiveRecording();\n        this._wasStopped = false;\n        client_core_1.StatsigMetadataProvider.add({ isRecordingSession: 'true' });\n        if (this._replayer.isRecording()) {\n            return;\n        }\n        this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {\n            this._shutdown();\n        });\n    }\n}\nexports.TriggeredSessionReplay = TriggeredSessionReplay;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}