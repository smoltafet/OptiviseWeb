{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useStatsigInternalClientFactoryAsync = void 0;\nconst react_1 = require(\"react\");\nconst client_core_1 = require(\"@statsig/client-core\");\nfunction useStatsigInternalClientFactoryAsync(factory, args) {\n  const client = (0, react_1.useMemo)(() => {\n    var _a;\n    return (_a = (0, client_core_1._getInstance)(args.sdkKey)) !== null && _a !== void 0 ? _a : factory(args);\n  }, []);\n  const [isLoading, setIsLoading] = (0, react_1.useState)(client.loadingStatus !== 'Ready');\n  (0, react_1.useMemo)(() => {\n    if (client.loadingStatus !== 'Ready') {\n      // Repeat calls to initializeAsync return the same promise.\n      // But if the client is already loaded, we don't want the promise\n      // resolution to trigger an extra render on `setIsLoading(false)`\n      client.initializeAsync().catch(client_core_1.Log.error).finally(() => setIsLoading(false));\n    }\n  }, []);\n  return {\n    client,\n    isLoading\n  };\n}\nexports.useStatsigInternalClientFactoryAsync = useStatsigInternalClientFactoryAsync;","map":{"version":3,"names":["Object","defineProperty","exports","value","useStatsigInternalClientFactoryAsync","react_1","require","client_core_1","factory","args","client","useMemo","_a","_getInstance","sdkKey","isLoading","setIsLoading","useState","loadingStatus","initializeAsync","catch","Log","error","finally"],"sources":["/Users/sidiq/Documents/OptiviseWeb/node_modules/@statsig/react-bindings/src/useStatsigInternalClientFactoryAsync.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useStatsigInternalClientFactoryAsync = void 0;\nconst react_1 = require(\"react\");\nconst client_core_1 = require(\"@statsig/client-core\");\nfunction useStatsigInternalClientFactoryAsync(factory, args) {\n    const client = (0, react_1.useMemo)(() => { var _a; return (_a = (0, client_core_1._getInstance)(args.sdkKey)) !== null && _a !== void 0 ? _a : factory(args); }, []);\n    const [isLoading, setIsLoading] = (0, react_1.useState)(client.loadingStatus !== 'Ready');\n    (0, react_1.useMemo)(() => {\n        if (client.loadingStatus !== 'Ready') {\n            // Repeat calls to initializeAsync return the same promise.\n            // But if the client is already loaded, we don't want the promise\n            // resolution to trigger an extra render on `setIsLoading(false)`\n            client\n                .initializeAsync()\n                .catch(client_core_1.Log.error)\n                .finally(() => setIsLoading(false));\n        }\n    }, []);\n    return { client, isLoading };\n}\nexports.useStatsigInternalClientFactoryAsync = useStatsigInternalClientFactoryAsync;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oCAAoC,GAAG,KAAK,CAAC;AACrD,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMC,aAAa,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AACrD,SAASF,oCAAoCA,CAACI,OAAO,EAAEC,IAAI,EAAE;EACzD,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEL,OAAO,CAACM,OAAO,EAAE,MAAM;IAAE,IAAIC,EAAE;IAAE,OAAO,CAACA,EAAE,GAAG,CAAC,CAAC,EAAEL,aAAa,CAACM,YAAY,EAAEJ,IAAI,CAACK,MAAM,CAAC,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGJ,OAAO,CAACC,IAAI,CAAC;EAAE,CAAC,EAAE,EAAE,CAAC;EACrK,MAAM,CAACM,SAAS,EAAEC,YAAY,CAAC,GAAG,CAAC,CAAC,EAAEX,OAAO,CAACY,QAAQ,EAAEP,MAAM,CAACQ,aAAa,KAAK,OAAO,CAAC;EACzF,CAAC,CAAC,EAAEb,OAAO,CAACM,OAAO,EAAE,MAAM;IACvB,IAAID,MAAM,CAACQ,aAAa,KAAK,OAAO,EAAE;MAClC;MACA;MACA;MACAR,MAAM,CACDS,eAAe,CAAC,CAAC,CACjBC,KAAK,CAACb,aAAa,CAACc,GAAG,CAACC,KAAK,CAAC,CAC9BC,OAAO,CAAC,MAAMP,YAAY,CAAC,KAAK,CAAC,CAAC;IAC3C;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAO;IAAEN,MAAM;IAAEK;EAAU,CAAC;AAChC;AACAb,OAAO,CAACE,oCAAoC,GAAGA,oCAAoC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}