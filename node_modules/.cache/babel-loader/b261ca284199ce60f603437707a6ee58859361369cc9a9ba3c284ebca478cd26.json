{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionReplayBase = exports.forceStartRecording = exports.startRecording = exports.stopRecording = void 0;\nconst client_core_1 = require(\"@statsig/client-core\");\nconst SessionReplayClient_1 = require(\"./SessionReplayClient\");\nconst SessionReplayUtils_1 = require(\"./SessionReplayUtils\");\nfunction stopRecording(sdkKey) {\n  var _a;\n  (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.stopRecording();\n}\nexports.stopRecording = stopRecording;\nfunction startRecording(sdkKey) {\n  var _a;\n  (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.startRecording();\n}\nexports.startRecording = startRecording;\nfunction forceStartRecording(sdkKey) {\n  var _a;\n  (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.forceStartRecording();\n}\nexports.forceStartRecording = forceStartRecording;\nfunction _getInstanceFromSdkKey(sdkKey) {\n  var _a, _b;\n  const inst = sdkKey == null ? (0, client_core_1._getStatsigGlobal)().firstSRInstance : (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];\n  return inst instanceof SessionReplayBase ? inst : null;\n}\nclass SessionReplayBase {\n  constructor(client, options) {\n    this._sessionData = {\n      startTime: -1,\n      endTime: 0,\n      clickCount: 0\n    };\n    this._events = [];\n    this._wasStopped = false;\n    this._currentEventIndex = 0;\n    this._totalLogs = 0;\n    this._client = client;\n    this._options = options;\n    const {\n      sdkKey,\n      errorBoundary\n    } = this._client.getContext();\n    this._errorBoundary = errorBoundary;\n    this._errorBoundary.wrap(this);\n    this._replayer = new SessionReplayClient_1.SessionReplayClient();\n    this._client.$on('pre_shutdown', () => this._shutdown());\n    this._client.on('session_expired', () => {\n      this._shutdown('session_expired');\n    });\n    if (!(0, client_core_1._isServerEnv)()) {\n      const statsigGlobal = (0, client_core_1._getStatsigGlobal)();\n      statsigGlobal.srInstances = Object.assign(Object.assign({}, statsigGlobal.srInstances), {\n        [sdkKey]: this\n      });\n      if (!statsigGlobal.firstSRInstance) {\n        statsigGlobal.firstSRInstance = this;\n      }\n    }\n    this._currentSessionID = this._getSessionIdFromClient();\n    this._subscribeToVisibilityChanged();\n  }\n  forceStartRecording() {\n    this._wasStopped = false;\n    this._attemptToStartRecording(true);\n  }\n  stopRecording() {\n    this._wasStopped = true;\n    this._shutdown();\n  }\n  startRecording() {\n    var _a;\n    this._wasStopped = false;\n    this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n  }\n  isRecording() {\n    return this._replayer.isRecording();\n  }\n  _logRecording(endReason) {\n    if (this._events.length === 0) {\n      return;\n    }\n    endReason = (0, client_core_1._isUnloading)() ? 'is_leaving_page' : endReason;\n    this._logRecordingWithSessionID(this._currentSessionID, endReason);\n  }\n  _onVisibilityChanged(visibility) {\n    if (visibility !== 'background') {\n      return;\n    }\n    this._logRecording();\n    this._client.flush().catch(e => {\n      this._errorBoundary.logError('SR::visibility', e);\n    });\n  }\n  _subscribeToVisibilityChanged() {\n    // Note: this exists as a separate function to ensure closure scope only contains `sdkKey`\n    const {\n      sdkKey\n    } = this._client.getContext();\n    (0, client_core_1._subscribeToVisiblityChanged)(vis => {\n      var _a, _b;\n      const inst = (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];\n      if (inst instanceof SessionReplayBase) {\n        inst._onVisibilityChanged(vis);\n      }\n    });\n  }\n  _logRecordingWithSessionID(sessionID, endReason) {\n    const data = this._sessionData;\n    if (this._events.length === 0) {\n      return;\n    }\n    const payload = JSON.stringify(this._events);\n    const parts = (0, SessionReplayUtils_1._slicePayload)(payload);\n    const slicedID = parts.length > 1 ? (0, client_core_1.getUUID)() : null;\n    for (let i = 0; i < parts.length; i++) {\n      const slice = parts[i];\n      const event = (0, SessionReplayUtils_1._makeLoggableRrwebEvent)(slice, payload, sessionID, data, this._client.getContext().sdkInstanceID);\n      if (slicedID != null) {\n        (0, SessionReplayUtils_1._appendSlicedMetadata)(event.metadata, slicedID, i, parts.length, slice.length);\n      }\n      if (endReason) {\n        event.metadata[endReason] = 'true';\n      }\n      this._totalLogs++;\n      this._client.logEvent(event);\n      if (slicedID != null) {\n        this._client.flush().catch(e => {\n          client_core_1.Log.error(e);\n        });\n      }\n    }\n    this._events = [];\n    if (this._totalLogs > SessionReplayUtils_1.MAX_LOGS) {\n      this._shutdown();\n    }\n  }\n  _bumpSessionIdleTimerAndLogRecording() {\n    this._getSessionIdFromClient();\n    this._logRecording();\n  }\n  _getSessionIdFromClient() {\n    return this._client.getContext().session.data.sessionID;\n  }\n  _shutdownImpl(endReason) {\n    if (this._replayer.isRecording()) {\n      this._replayer.stop();\n      const handler = () => {\n        client_core_1.StatsigMetadataProvider.add({\n          isRecordingSession: 'false'\n        });\n        this._client.off('logs_flushed', handler);\n      };\n      this._client.$on('logs_flushed', handler);\n    }\n    if (this._events.length === 0) {\n      // only reset if session expired otherwise we might start recording again\n      if (endReason === 'session_expired') {\n        this._currentEventIndex = 0;\n        this._sessionData = this._makeEmptySessionData();\n      }\n      return;\n    }\n    this._logRecording(endReason);\n    // only reset if session expired otherwise we might start recording again\n    if (endReason === 'session_expired') {\n      this._currentEventIndex = 0;\n      this._sessionData = this._makeEmptySessionData();\n    }\n  }\n  _makeEmptySessionData() {\n    return {\n      startTime: -1,\n      endTime: 0,\n      clickCount: 0\n    };\n  }\n  _onRecordingEvent(event, data) {\n    // The session has expired so we should stop recording\n    if (this._currentSessionID !== this._getSessionIdFromClient()) {\n      this._shutdown('session_expired');\n      return;\n    }\n    if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {\n      this._shutdown();\n      return;\n    }\n    event.eventIndex = this._currentEventIndex++;\n    // Update the session data\n    this._sessionData.clickCount += data.clickCount;\n    this._sessionData.startTime = this._sessionData.startTime === -1 ? data.startTime : Math.min(this._sessionData.startTime, data.startTime);\n    this._sessionData.endTime = Math.max(this._sessionData.endTime, data.endTime);\n    const eventApproxSize = (0, client_core_1._fastApproxSizeOf)(event, SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES);\n    if (eventApproxSize > SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES) {\n      client_core_1.Log.warn(`SessionReplay event is too large (~${eventApproxSize} bytes) and will not be logged`, event);\n      return;\n    }\n    const approxArraySizeBefore = (0, client_core_1._fastApproxSizeOf)(this._events, SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES);\n    this._events.push(event);\n    if (approxArraySizeBefore + eventApproxSize < SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES) {\n      return;\n    }\n    if ((0, client_core_1._isCurrentlyVisible)()) {\n      this._bumpSessionIdleTimerAndLogRecording();\n    } else {\n      this._logRecording();\n    }\n  }\n}\nexports.SessionReplayBase = SessionReplayBase;","map":{"version":3,"names":["Object","defineProperty","exports","value","SessionReplayBase","forceStartRecording","startRecording","stopRecording","client_core_1","require","SessionReplayClient_1","SessionReplayUtils_1","sdkKey","_a","_getInstanceFromSdkKey","_b","inst","_getStatsigGlobal","firstSRInstance","srInstances","constructor","client","options","_sessionData","startTime","endTime","clickCount","_events","_wasStopped","_currentEventIndex","_totalLogs","_client","_options","errorBoundary","getContext","_errorBoundary","wrap","_replayer","SessionReplayClient","$on","_shutdown","on","_isServerEnv","statsigGlobal","assign","_currentSessionID","_getSessionIdFromClient","_subscribeToVisibilityChanged","_attemptToStartRecording","forceRecording","isRecording","_logRecording","endReason","length","_isUnloading","_logRecordingWithSessionID","_onVisibilityChanged","visibility","flush","catch","e","logError","_subscribeToVisiblityChanged","vis","sessionID","data","payload","JSON","stringify","parts","_slicePayload","slicedID","getUUID","i","slice","event","_makeLoggableRrwebEvent","sdkInstanceID","_appendSlicedMetadata","metadata","logEvent","Log","error","MAX_LOGS","_bumpSessionIdleTimerAndLogRecording","session","_shutdownImpl","stop","handler","StatsigMetadataProvider","add","isRecordingSession","off","_makeEmptySessionData","_onRecordingEvent","eventIndex","Math","min","max","eventApproxSize","_fastApproxSizeOf","MAX_INDIVIDUAL_EVENT_BYTES","warn","approxArraySizeBefore","REPLAY_ENQUEUE_TRIGGER_BYTES","push","_isCurrentlyVisible"],"sources":["/Users/sidiq/Documents/OptiviseWeb/node_modules/@statsig/session-replay/src/SessionReplayBase.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SessionReplayBase = exports.forceStartRecording = exports.startRecording = exports.stopRecording = void 0;\nconst client_core_1 = require(\"@statsig/client-core\");\nconst SessionReplayClient_1 = require(\"./SessionReplayClient\");\nconst SessionReplayUtils_1 = require(\"./SessionReplayUtils\");\nfunction stopRecording(sdkKey) {\n    var _a;\n    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.stopRecording();\n}\nexports.stopRecording = stopRecording;\nfunction startRecording(sdkKey) {\n    var _a;\n    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.startRecording();\n}\nexports.startRecording = startRecording;\nfunction forceStartRecording(sdkKey) {\n    var _a;\n    (_a = _getInstanceFromSdkKey(sdkKey)) === null || _a === void 0 ? void 0 : _a.forceStartRecording();\n}\nexports.forceStartRecording = forceStartRecording;\nfunction _getInstanceFromSdkKey(sdkKey) {\n    var _a, _b;\n    const inst = sdkKey == null\n        ? (0, client_core_1._getStatsigGlobal)().firstSRInstance\n        : (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];\n    return inst instanceof SessionReplayBase ? inst : null;\n}\nclass SessionReplayBase {\n    constructor(client, options) {\n        this._sessionData = {\n            startTime: -1,\n            endTime: 0,\n            clickCount: 0,\n        };\n        this._events = [];\n        this._wasStopped = false;\n        this._currentEventIndex = 0;\n        this._totalLogs = 0;\n        this._client = client;\n        this._options = options;\n        const { sdkKey, errorBoundary } = this._client.getContext();\n        this._errorBoundary = errorBoundary;\n        this._errorBoundary.wrap(this);\n        this._replayer = new SessionReplayClient_1.SessionReplayClient();\n        this._client.$on('pre_shutdown', () => this._shutdown());\n        this._client.on('session_expired', () => {\n            this._shutdown('session_expired');\n        });\n        if (!(0, client_core_1._isServerEnv)()) {\n            const statsigGlobal = (0, client_core_1._getStatsigGlobal)();\n            statsigGlobal.srInstances = Object.assign(Object.assign({}, statsigGlobal.srInstances), { [sdkKey]: this });\n            if (!statsigGlobal.firstSRInstance) {\n                statsigGlobal.firstSRInstance = this;\n            }\n        }\n        this._currentSessionID = this._getSessionIdFromClient();\n        this._subscribeToVisibilityChanged();\n    }\n    forceStartRecording() {\n        this._wasStopped = false;\n        this._attemptToStartRecording(true);\n    }\n    stopRecording() {\n        this._wasStopped = true;\n        this._shutdown();\n    }\n    startRecording() {\n        var _a;\n        this._wasStopped = false;\n        this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);\n    }\n    isRecording() {\n        return this._replayer.isRecording();\n    }\n    _logRecording(endReason) {\n        if (this._events.length === 0) {\n            return;\n        }\n        endReason = (0, client_core_1._isUnloading)() ? 'is_leaving_page' : endReason;\n        this._logRecordingWithSessionID(this._currentSessionID, endReason);\n    }\n    _onVisibilityChanged(visibility) {\n        if (visibility !== 'background') {\n            return;\n        }\n        this._logRecording();\n        this._client.flush().catch((e) => {\n            this._errorBoundary.logError('SR::visibility', e);\n        });\n    }\n    _subscribeToVisibilityChanged() {\n        // Note: this exists as a separate function to ensure closure scope only contains `sdkKey`\n        const { sdkKey } = this._client.getContext();\n        (0, client_core_1._subscribeToVisiblityChanged)((vis) => {\n            var _a, _b;\n            const inst = (_b = (_a = (0, client_core_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.srInstances) === null || _b === void 0 ? void 0 : _b[sdkKey];\n            if (inst instanceof SessionReplayBase) {\n                inst._onVisibilityChanged(vis);\n            }\n        });\n    }\n    _logRecordingWithSessionID(sessionID, endReason) {\n        const data = this._sessionData;\n        if (this._events.length === 0) {\n            return;\n        }\n        const payload = JSON.stringify(this._events);\n        const parts = (0, SessionReplayUtils_1._slicePayload)(payload);\n        const slicedID = parts.length > 1 ? (0, client_core_1.getUUID)() : null;\n        for (let i = 0; i < parts.length; i++) {\n            const slice = parts[i];\n            const event = (0, SessionReplayUtils_1._makeLoggableRrwebEvent)(slice, payload, sessionID, data, this._client.getContext().sdkInstanceID);\n            if (slicedID != null) {\n                (0, SessionReplayUtils_1._appendSlicedMetadata)(event.metadata, slicedID, i, parts.length, slice.length);\n            }\n            if (endReason) {\n                event.metadata[endReason] = 'true';\n            }\n            this._totalLogs++;\n            this._client.logEvent(event);\n            if (slicedID != null) {\n                this._client.flush().catch((e) => {\n                    client_core_1.Log.error(e);\n                });\n            }\n        }\n        this._events = [];\n        if (this._totalLogs > SessionReplayUtils_1.MAX_LOGS) {\n            this._shutdown();\n        }\n    }\n    _bumpSessionIdleTimerAndLogRecording() {\n        this._getSessionIdFromClient();\n        this._logRecording();\n    }\n    _getSessionIdFromClient() {\n        return this._client.getContext().session.data.sessionID;\n    }\n    _shutdownImpl(endReason) {\n        if (this._replayer.isRecording()) {\n            this._replayer.stop();\n            const handler = () => {\n                client_core_1.StatsigMetadataProvider.add({ isRecordingSession: 'false' });\n                this._client.off('logs_flushed', handler);\n            };\n            this._client.$on('logs_flushed', handler);\n        }\n        if (this._events.length === 0) {\n            // only reset if session expired otherwise we might start recording again\n            if (endReason === 'session_expired') {\n                this._currentEventIndex = 0;\n                this._sessionData = this._makeEmptySessionData();\n            }\n            return;\n        }\n        this._logRecording(endReason);\n        // only reset if session expired otherwise we might start recording again\n        if (endReason === 'session_expired') {\n            this._currentEventIndex = 0;\n            this._sessionData = this._makeEmptySessionData();\n        }\n    }\n    _makeEmptySessionData() {\n        return {\n            startTime: -1,\n            endTime: 0,\n            clickCount: 0,\n        };\n    }\n    _onRecordingEvent(event, data) {\n        // The session has expired so we should stop recording\n        if (this._currentSessionID !== this._getSessionIdFromClient()) {\n            this._shutdown('session_expired');\n            return;\n        }\n        if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {\n            this._shutdown();\n            return;\n        }\n        event.eventIndex = this._currentEventIndex++;\n        // Update the session data\n        this._sessionData.clickCount += data.clickCount;\n        this._sessionData.startTime =\n            this._sessionData.startTime === -1\n                ? data.startTime\n                : Math.min(this._sessionData.startTime, data.startTime);\n        this._sessionData.endTime = Math.max(this._sessionData.endTime, data.endTime);\n        const eventApproxSize = (0, client_core_1._fastApproxSizeOf)(event, SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES);\n        if (eventApproxSize > SessionReplayUtils_1.MAX_INDIVIDUAL_EVENT_BYTES) {\n            client_core_1.Log.warn(`SessionReplay event is too large (~${eventApproxSize} bytes) and will not be logged`, event);\n            return;\n        }\n        const approxArraySizeBefore = (0, client_core_1._fastApproxSizeOf)(this._events, SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES);\n        this._events.push(event);\n        if (approxArraySizeBefore + eventApproxSize <\n            SessionReplayUtils_1.REPLAY_ENQUEUE_TRIGGER_BYTES) {\n            return;\n        }\n        if ((0, client_core_1._isCurrentlyVisible)()) {\n            this._bumpSessionIdleTimerAndLogRecording();\n        }\n        else {\n            this._logRecording();\n        }\n    }\n}\nexports.SessionReplayBase = SessionReplayBase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}